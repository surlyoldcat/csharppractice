/*
https://projecteuler.net/problem=2
Each new term in the Fibonacci sequence is generated by adding the previous two terms. By starting with 1 and 2, the first 10 terms will be:

1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...

By considering the terms in the Fibonacci sequence whose values do not exceed four million, find the sum of the even-valued terms.
*/
using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;

namespace ProjectEProbs._1to50
{
    public class Prob2
    {

        public static int EvenFibonacciSum(int maxval)
        {
            if (maxval <= 0)
                return 0;
            else if (maxval == 1)
                return 1;

            int runningTotal = 0;
            foreach (int fib in FibonacciGen(maxval))
            {
                if (fib % 2 == 0)
                {
                    runningTotal += fib;
                    System.Diagnostics.Debug.WriteLine($"Including fib # {fib}");
                }
                else
                {
                    System.Diagnostics.Debug.WriteLine($"Skipping fib # {fib}");
                }
            }
            return runningTotal;

        }

        public static int FibonacciNumMax(int maxval)
        {
            if (maxval <= 0)
                return 0;
            else if (maxval == 1)
                return 1;
            
            Tuple<int, int, int> workSet = new Tuple<int, int, int>(0, 1, 1);
            while (workSet.Item3 <= maxval)
            {
                int new1 = workSet.Item2;
                int new2 = workSet.Item3;
                workSet = new Tuple<int, int, int>(new1, new2, new1 + new2);                
            }
            if (workSet.Item3 > maxval)
                return workSet.Item2;
            else
                return workSet.Item3;
        }

        public static IEnumerable<int> FibonacciGen(int upperLimit)
        {
            Tuple<int, int, int> workSet = new Tuple<int, int, int>(0, 1, 1);
            while (workSet.Item3 <= upperLimit)
            {
                int new1 = workSet.Item2;
                int new2 = workSet.Item3;
                workSet = new Tuple<int, int, int>(new1, new2, new1 + new2);
                if (workSet.Item3 > upperLimit)
                    yield break;
                else               
                    yield return workSet.Item3;
            }

        }
    }
}
